user root;

worker_processes  1;

events { worker_connections 1024; }

error_log /dev/stderr error;

http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile      on;
    keepalive_timeout 65;
    client_max_body_size 500M;
    
    # === Shared dict untuk router & balancing ===
    lua_shared_dict domains        10m;  # domain -> pool
    lua_shared_dict pools          10m;  # pool:<name> -> jslog_by_lua_block n(backends[]), rr:<name> -> counter (jika perlu)
    lua_shared_dict conn_shdict     2m;  # counter koneksi aktif per node (least-connections)
    lua_shared_dict health_shdict   2m;  # status health pasif: "down:<pool>:<ip:port>" -> 1 (TTL)

    # === Tambahan untuk metrics ===
    lua_shared_dict metrics        20m;  # penyimpan counter trafik

    # Load domains + pools saat worker start/reload
    init_worker_by_lua_file /etc/nginx/lua/domain_loader.lua;

    # Redirect semua www ke non-www (HTTP)
    server {
        listen 80;
        server_name ~^www\.(?<base>.+)$;

        # Tetap izinkan challenge agar certbot bisa jalan
        location ^~ /.well-known/acme-challenge/ {
            root /var/www/certbot;
            allow all;
            try_files $uri =404;
        }

        return 301 http://$base$request_uri;
    }
    # ===== Port 80 (Default) =====
    server {
        listen 80 default_server;
        server_name _ localhost;

        # ACME webroot (HTTP only)
        location ^~ /.well-known/acme-challenge/ {
            access_log /var/log/nginx/access.log combined;
            root /var/www/certbot;
            allow all;
            try_files $uri =404;
        }

        # API (Flask)
        location /api/ {
            proxy_pass http://127.0.0.1:5000;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }

        # Router HTTP dinamis (domain apapun)
        location / {
            set $upstream "";
            set $pool     "";
            set $prev_up  "";

            # Pilih upstream via Lua (least-connections + health pasif)
            access_by_lua_file /etc/nginx/lua/router.lua;

            # Simpan pilihan pertama (dipakai untuk hindari saat retry)
            set $prev_up  $upstream;

            # Header debug
            add_header X-Upstream       $upstream       always;
            add_header X-Pool           $pool           always;
            # add_header X-Used-Upstream  $upstream_addr  always;

            # ✅ Tambah header filter agar X-Used-Upstream terkirim
            header_filter_by_lua_block {
                local addr = ngx.var.upstream_addr or ""
                -- Ambil alamat terakhir setelah koma
                local last = addr:match("([^,]+)$") or addr
                if last ~= "" then
                    ngx.header["X-Used-Upstream"] = last
                end
            }

            proxy_pass http://$upstream;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

            # Kelola retry manual
            proxy_next_upstream off;
            proxy_intercept_errors on;
            error_page 500 502 503 504 = @retry;

            proxy_connect_timeout 5s;
            proxy_read_timeout 30s;
            proxy_send_timeout 30s;
        }

        # Named location untuk RETRY (maks 1x)
        location @retry {
            set $upstream "";
            set $pool     "";

            # SATU handler access saja: tandai retry + jalankan router.lua
            access_by_lua_block {
                ngx.req.set_header("X-Retry", "1")

                local prev = ngx.var.prev_up or ngx.var.upstream or ""
                if prev ~= "" then
                    ngx.req.set_header("X-Prev-Upstream", prev)
                end

                dofile("/etc/nginx/lua/router.lua")
            }

            # header debug
            add_header X-Upstream       $upstream       always;
            add_header X-Pool           $pool           always;
            # add_header X-Used-Upstream  $upstream_addr  always;

            # ✅ Tambah header filter agar X-Used-Upstream terkirim
            header_filter_by_lua_block {
                local addr = ngx.var.upstream_addr or ""
                local last = addr:match("([^,]+)$") or addr
                if last ~= "" then
                    ngx.header["X-Used-Upstream"] = last
                end
            }

            proxy_pass http://$upstream;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

            proxy_next_upstream off;  # cegah loop
        }


        log_by_lua_block {
            local hs  = ngx.shared.health_shdict
            local con = ngx.shared.conn_shdict

            local u = ngx.var.upstream_addr or ""
            if u ~= "" then
                -- Ambil backend terakhir saja
                local last = u:match("([^,]+)$") or u

                -- update counter koneksi
                local addr = last:gsub("^%s+", ""):gsub("%s+$", "")
                if addr ~= "" then
                    con:incr("conn:" .. addr, -1, 0)
                end
            end

            local st = ngx.var.upstream_status or ""
            if st ~= "" and st:match("^5") then
                local pool = ngx.var.pool or ""
                local last = u:match("([^,]+)$") or u
                if pool ~= "" and last ~= "" then
                    hs:set("down:" .. pool .. ":" .. last, 1, 10)
                end
            end
        }
    }

    # ===== Port 80 untuk *.isipage.com (redirect ke HTTPS) =====
    server {
        listen 80;
        server_name ~^(?<subdomain>.+)\.isipage\.com$;

        location ^~ /.well-known/acme-challenge/ {
            root /var/www/certbot;
            allow all;
            try_files $uri =404;
        }

        return 301 https://$host$request_uri;
    }

    # ===== Port 443 untuk *.isipage.com (SSL statis) =====
    server {
        listen 443 ssl;
        http2 on;
        server_name ~^(?<subdomain>.+)\.isipage\.com$;

        ssl_certificate     /etc/nginx/ssl/isipage.crt;
        ssl_certificate_key /etc/nginx/ssl/isipage.key;

        location / {
            set $upstream "";
            set $pool     "";
            set $prev_up  "";

            access_by_lua_file /etc/nginx/lua/router.lua;
            set $prev_up  $upstream;

            add_header X-Upstream       $upstream       always;
            add_header X-Pool           $pool           always;
            # add_header X-Used-Upstream  $upstream_addr  always;

            header_filter_by_lua_block {
                local addr = ngx.var.upstream_addr or ""
                local last = addr:match("([^,]+)$") or addr
                if last ~= "" then
                    ngx.header["X-Used-Upstream"] = last
                end
            }

            proxy_pass http://$upstream;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

            proxy_next_upstream off;
            proxy_intercept_errors on;
            error_page 500 502 503 504 = @retry;
        }

        location @retry {
            set $upstream "";
            set $pool     "";

            access_by_lua_block {
                -- tandai ini percobaan ke-2
                ngx.req.set_header("X-Retry", "1")
                local prev = ngx.var.prev_up or ngx.var.upstream or ""
                if prev ~= "" then
                    ngx.req.set_header("X-Prev-Upstream", prev)
                end
                -- pilih ULANG node
                dofile("/etc/nginx/lua/router.lua")
            }

            add_header X-Upstream       $upstream       always;
            add_header X-Pool           $pool           always;
            # add_header X-Used-Upstream  $upstream_addr  always;

            header_filter_by_lua_block {
                local addr = ngx.var.upstream_addr or ""
                local last = addr:match("([^,]+)$") or addr
                if last ~= "" then
                    ngx.header["X-Used-Upstream"] = last
                end
            }

            proxy_pass http://$upstream;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_next_upstream off;
        }

        log_by_lua_block {
            local hs  = ngx.shared.health_shdict
            local con = ngx.shared.conn_shdict

            local u = ngx.var.upstream_addr or ""
            if u ~= "" then
                local last = u:match("([^,]+)$") or u
                local addr = last:gsub("^%s+", ""):gsub("%s+$", "")
                if addr ~= "" then
                    con:incr("conn:" .. addr, -1, 0)
                end
            end

            local st = ngx.var.upstream_status or ""
            if st ~= "" and st:match("^5") then
                local pool = ngx.var.pool or ""
                local last = u:match("([^,]+)$") or u
                if pool ~= "" and last ~= "" then
                    hs:set("down:" .. pool .. ":" .. last, 1, 10)
                end
            end
        }
    }
    # Redirect semua www ke non-www (HTTPS)
    server {
        listen 443 ssl;
        http2 on;
        server_name ~^www\.(?<base>.+)$;

        # Pakai cert dari base domain (harus valid SAN: domain + www.domain)
        ssl_certificate     /var/lib/certbot/live/$base/fullchain.pem;
        ssl_certificate_key /var/lib/certbot/live/$base/privkey.pem;

        return 301 https://$base$request_uri;
    }
    # ===== Port 443 Dinamis (LE webroot + SNI dynamic) =====
    server {
        listen 443 ssl default_server;
        http2 on;
        server_name _;  # selain *.isipage.com

        # fallback dummy cert; real cert via SNI dinamis
        ssl_certificate     /etc/nginx/ssl/dummy.crt;
        ssl_certificate_key /etc/nginx/ssl/dummy.key;

        ssl_certificate_by_lua_block {
            local ssl = require("ngx.ssl")
            local domain = ssl.server_name()
            if not domain or domain == "" then
                ngx.log(ngx.WARN, "No SNI; keep dummy cert")
                return
            end

            -- default: cari folder persis domain
            local cert_path = "/var/lib/certbot/live/" .. domain .. "/fullchain.pem"
            local key_path  = "/var/lib/certbot/live/" .. domain .. "/privkey.pem"

            -- fallback: kalau folder domain tidak ada, coba hapus "www."
            local function file_exists(p)
                local f = io.open(p, "r")
                if f then f:close(); return true end
                return false
            end

            if not file_exists(cert_path) and domain:match("^www%.(.+)$") then
                local base = domain:match("^www%.(.+)$")
                cert_path = "/var/lib/certbot/live/" .. base .. "/fullchain.pem"
                key_path  = "/var/lib/certbot/live/" .. base .. "/privkey.pem"
                ngx.log(ngx.NOTICE, "Fallback SSL for " .. domain .. " -> using base domain " .. base)
            end

            local function read_all(p)
                local f = io.open(p, "r")
                if not f then return nil end
                local s = f:read("*a"); f:close(); return s
            end

            local cert_pem = read_all(cert_path)
            local key_pem  = read_all(key_path)
            if not cert_pem or not key_pem then
                ngx.log(ngx.WARN, "SSL not found/complete for " .. domain .. "; keep dummy cert")
                return
            end

            local ok, err = ssl.clear_certs()
            if not ok then
                ngx.log(ngx.ERR, "clear_certs failed: ", err); return
            end
            local der_cert, derr = ssl.cert_pem_to_der(cert_pem)
            if not der_cert then
                ngx.log(ngx.ERR, "cert_pem_to_der failed: ", derr); return
            end
            ok, err = ssl.set_der_cert(der_cert)
            if not ok then
                ngx.log(ngx.ERR, "set_der_cert failed: ", err); return
            end
            local der_key, kerr = ssl.priv_key_pem_to_der(key_pem)
            if not der_key then
                ngx.log(ngx.ERR, "priv_key_pem_to_der failed: ", kerr); return
            end
            ok, err = ssl.set_der_priv_key(der_key)
            if not ok then
                ngx.log(ngx.ERR, "set_der_priv_key failed: ", err); return
            end
        }


        location / {
            set $upstream "";
            set $pool     "";
            set $prev_up  "";

            access_by_lua_file /etc/nginx/lua/router.lua;
            set $prev_up  $upstream;

            add_header X-Upstream       $upstream       always;
            add_header X-Pool           $pool           always;
            # add_header X-Used-Upstream  $upstream_addr  always;

            header_filter_by_lua_block {
                local addr = ngx.var.upstream_addr or ""
                local last = addr:match("([^,]+)$") or addr
                if last ~= "" then
                    ngx.header["X-Used-Upstream"] = last
                end
            }

            proxy_pass http://$upstream;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

            proxy_next_upstream off;
            proxy_intercept_errors on;
            error_page 500 502 503 504 = @retry;
        }

        location @retry {
            set $upstream "";
            set $pool     "";

            access_by_lua_block {
                -- tandai ini percobaan ke-2
                ngx.req.set_header("X-Retry", "1")
                local prev = ngx.var.prev_up or ngx.var.upstream or ""
                if prev ~= "" then
                    ngx.req.set_header("X-Prev-Upstream", prev)
                end
                -- pilih ULANG node
                dofile("/etc/nginx/lua/router.lua")
            }

            add_header X-Upstream       $upstream       always;
            add_header X-Pool           $pool           always;
            # add_header X-Used-Upstream  $upstream_addr  always;

            header_filter_by_lua_block {
                local addr = ngx.var.upstream_addr or ""
                local last = addr:match("([^,]+)$") or addr
                if last ~= "" then
                    ngx.header["X-Used-Upstream"] = last
                end
            }

            proxy_pass http://$upstream;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_next_upstream off;
        }

        log_by_lua_block {
            local hs  = ngx.shared.health_shdict
            local con = ngx.shared.conn_shdict

            local u = ngx.var.upstream_addr or ""
            if u ~= "" then
                -- Ambil backend terakhir saja
                local last = u:match("([^,]+)$") or u

                -- update counter koneksi
                local addr = last:gsub("^%s+", ""):gsub("%s+$", "")
                if addr ~= "" then
                    con:incr("conn:" .. addr, -1, 0)
                end
            end

            local st = ngx.var.upstream_status or ""
            if st ~= "" and st:match("^5") then
                local pool = ngx.var.pool or ""
                local last = u:match("([^,]+)$") or u
                if pool ~= "" and last ~= "" then
                    hs:set("down:" .. pool .. ":" .. last, 1, 10)
                end
            end
        }
    }
}
